<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>날아라 멀캠러</title>
  <style>
    :root{
      --bg:#ffffff;
      --panel:#ffffff;
      --text:#0e1220;
      --accent:#ff7a17;
      --muted:#6b7280;
      --line:#e9edf3;
      --shadow:rgba(0,0,0,0.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, "Noto Sans KR", "맑은 고딕", sans-serif;}
    #gameWrap{
      position:relative;width:100%;
      height:calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      padding-top:env(safe-area-inset-top); padding-bottom:env(safe-area-inset-bottom);
      overflow:hidden; background:var(--bg);
    }
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;background:#ffffff;}
    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(255,255,255,0.75);
      padding:clamp(12px, 3vw, 24px); z-index:6;
      -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);
    }
    .panel{
      width:min(760px,94vw);
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      padding:clamp(14px, 2.8vw, 22px);
      box-shadow:0 10px 24px var(--shadow);
    }
    .title{font-weight:800; font-size: clamp(20px, 5.2vw, 34px); line-height:1.2; margin:4px 0 8px;}
    .subtitle{color:var(--muted); margin:0 0 14px; font-size:clamp(12px, 3.4vw, 14px)}
    .grid{display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(56px, 1fr));}
    .charBtn{
      display:flex; align-items:center; justify-content:center;
      padding:clamp(10px, 3.2vw, 14px) 0;
      border-radius:12px; border:1px solid var(--line);
      background:#fff; cursor:pointer; transition: all .15s ease;
      user-select:none; box-shadow:0 2px 6px var(--shadow);
    }
    .charBtn img{width:clamp(28px, 6.4vw, 32px); height:clamp(28px, 6.4vw, 32px)}
    .charBtn[data-selected="true"]{outline:2px solid var(--accent); transform: translateY(-2px); background:#fff6ef;}
    .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
    .row + .row{margin-top:10px}
    .tag{font-size:12px; padding:6px 10px; background:#f8fafc; border:1px solid var(--line); border-radius:999px; color:#111827;}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:12px;border:1px solid var(--line);background:#fff; box-shadow:0 1px 4px var(--shadow); font-weight:600}
    label{display:inline-flex; align-items:center; gap:8px; cursor:pointer}
    input[type="radio"]{accent-color:var(--accent); width:18px; height:18px;}
    .actions{display:flex; gap:8px; flex-wrap:wrap; margin-top:12px}
    .btn{
      appearance:none; border:1px solid var(--line); background:#fff; color:#0b1020;
      padding:12px 16px; border-radius:12px; cursor:pointer; font-weight:800; transition:.15s;
      box-shadow:0 2px 6px var(--shadow); font-size:clamp(14px, 3.6vw, 16px);
    }
    .btn.primary{background:var(--accent); border-color:#ef6b05; color:#111; }
    .btn:active{transform: translateY(1px)}
    .list{margin-top:10px}
    .list table{width:100%; border-collapse:collapse; font-size:14px}
    .list th,.list td{padding:8px 6px; border-bottom:1px solid var(--line); text-align:left}
    .muted{color:#6b7280}

    /* HUD */
    .cornerHUD{
      position:absolute; left:12px; top:52px; z-index:8; display:flex; flex-direction:column; gap:6px;
      background:rgba(255,255,255,0.85); padding:8px 10px; border-radius:10px; border:1px solid var(--line);
      backdrop-filter: blur(4px);
      font-weight:700;
    }
    .cornerHUD .row{gap:8px}
    .cornerHUD .kv{display:flex; gap:6px; align-items:center}
    .kv .k{color:#374151; font-size:12px}
    .kv .v{font-size:16px}
    .lives{display:flex; gap:4px; font-size:18px; align-items:center}
    .invTag{display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; background:#fff3bf; border:1px solid #ffe58f; font-size:12px; color:#7c5b00}

    /* Sound toggle */
    .soundToggle{
      position:absolute; right:12px; top: calc(env(safe-area-inset-top) + 10px);
      z-index: 20; user-select:none;
      background:rgba(255,255,255,0.85); border:1px solid var(--line); border-radius:999px;
      padding:4px 10px; font-weight:800; display:inline-flex; align-items:center; gap:8px;
      backdrop-filter: blur(4px);
    }
    .soundToggle button{ background:none; border:none; font:inherit; cursor:pointer; }
    .soundToggle .icon{font-size:18px}

    /* MC logo IMG (32px) */
    .mc-logo-img{
      position:absolute; left:12px; top: calc(env(safe-area-inset-top) + 10px);
      z-index: 20; pointer-events:none;
      width:32px; height:32px; object-fit:contain; image-rendering:auto;
      -webkit-user-drag:none; user-select:none;
    }

    /* Game Over */
    .goWrap .score{font-size:40px; font-weight:800; margin:6px 0 12px}
    .goWrap input[type="text"]{width:100%; padding:12px 14px; border-radius:10px; border:1px solid var(--line); background:#fff; color:#0b1020;}
    .footnote{font-size:12px; color:#6b7280; margin-top:6px}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game"></canvas>

    <!-- 멀티캠퍼스 이미지 로고 (32px) -->
    <img class="mc-logo-img" alt="multicampus" src="https://api.multicampus.com/ssf/v1/resource/public/images/FILBS202506207041267"/>

    <div class="soundToggle"><span class="icon" id="soundIcon">🔊</span><button id="btnSound">사운드 ON</button></div>

    <div class="cornerHUD" id="hud" style="display:none">
      <div class="row">
        <span class="tag" id="hudDiff">난이도: -</span>
        <span class="tag" id="hudChar">캐릭터: -</span>
      </div>
      <div class="row">
        <div class="kv"><span class="k">점수</span><span class="v" id="hudScore">0</span></div>
        <div class="kv"><span class="k">시간</span><span class="v" id="hudTime">0.0s</span></div>
        <div class="kv"><span class="k">콤보</span><span class="v" id="hudCombo">0</span></div>
      </div>
      <div class="row">
        <div class="lives" id="hudLives" title="라이프(❤️)"></div>
        <span class="invTag" id="invTag" style="display:none">🛡 무적 <span id="invLeft">3.0</span>s</span>
      </div>
    </div>

    <!-- Start Screen -->
    <div class="overlay" id="startScreen">
      <div class="panel">
        <div class="title">날아라 멀캠러!</div>
        <p class="subtitle">아주 멀리 달려보세요! <b>🤣</b></p>
        <div class="row"><span class="tag">1) 캐릭터 선택</span></div>
        <div class="grid" id="charGrid" aria-label="캐릭터 선택"></div>

        <div class="row" style="margin-top:16px"><span class="tag">2) 난이도 선택</span></div>
        <div class="row" role="radiogroup" aria-label="난이도">
          <label class="pill"><input type="radio" name="difficulty" value="easy" checked>하</label>
          <label class="pill"><input type="radio" name="difficulty" value="normal">중</label>
          <label class="pill"><input type="radio" name="difficulty" value="hard">상</label>
        </div>

        <div class="actions">
          <button class="btn primary" id="btnStart">게임 시작</button>
          <button class="btn" id="btnShowRank">랭킹 보기</button>
        </div>

        <div class="list" id="rankListStart" style="display:none"></div>

        <p class="footnote">조작: 스페이스/↑ 또는 화면 탭. 공중에서도 한 번 더 눌러 <b>이단 점프</b> 가능. 시작 목숨 2(최대 3). ❤️로 회복, 🪨로 3초 무적. 우측 상단에서 사운드 ON/OFF.</p>
      </div>
    </div>

    <!-- Game Over -->
    <div class="overlay" id="gameOverScreen" style="display:none">
      <div class="panel goWrap">
        <div class="title">게임 종료</div>
        <div class="score"><span id="finalScore">0</span> 점</div>
        <div class="row"><span class="tag" id="finalMeta">-</span></div>
        <div style="margin:10px 0 8px">이름(닉네임)을 입력해 랭킹에 등록하세요.</div>
        <input type="text" id="playerName" maxlength="20" placeholder="예: 멀캠러너" />
        <div class="actions">
          <button class="btn primary" id="btnSaveScore">랭킹 저장</button>
          <button class="btn" id="btnRetry">다시 하기</button>
          <button class="btn" id="btnGoHome">처음으로</button>
          <button class="btn" id="btnShowRank2">랭킹 보기</button>
        </div>
        <div class="list" id="rankListEnd" style="display:none"></div>
        <p class="footnote">랭킹등록완료</p>
      </div>
    </div>
  </div>

  <script>
  (()=>{
    // ---------- Emoji → Twemoji image (cross-platform) ----------
    // Uses jsDelivr Twemoji assets (SVG). Draws images on canvas instead of emoji text.
    const TWEMOJI_BASE = "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/";
    function toCodePoints(str){
      const cps = [];
      for (let i = 0; i < str.length; i++){
        const code = str.codePointAt(i);
        cps.push(code.toString(16));
        if (code > 0xffff) i++;
      }
      // Keep VS16 (fe0f) when present to force emoji variant
      return cps.join("-");
    }
    function emojiUrl(emoji){ return TWEMOJI_BASE + toCodePoints(emoji) + ".svg"; }

    const imageCache = new Map();
    function loadEmojiImage(emoji){
      const key = emoji;
      if (imageCache.has(key)) return imageCache.get(key);
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.src = emojiUrl(emoji);
      imageCache.set(key, img);
      return img;
    }

    // ---------- Simple SFX using Web Audio ----------
    const SFX = (()=>{
      let ctx = null, master = null, muted = false, started = false;
      const STORAGE_MUTE = "mc_runner_mute";
      function ensure(){
        if(muted) return false;
        if(!ctx){
          const AC = window.AudioContext || window.webkitAudioContext;
          ctx = new AC();
          master = ctx.createGain();
          master.gain.value = 0.35;
          master.connect(ctx.destination);
        }
        if(ctx.state === "suspended") ctx.resume();
        return true;
      }
      function env(startTime, dur, a=0.005, d=0.08, s=0.6, r=0.12){
        const g = ctx.createGain();
        const t0 = startTime;
        g.gain.setValueAtTime(0, t0);
        g.gain.linearRampToValueAtTime(1, t0 + a);
        g.gain.linearRampToValueAtTime(s, t0 + a + d);
        g.gain.linearRampToValueAtTime(0, t0 + dur + r);
        return g;
      }
      function tone({type="sine", f0=400, f1=null, dur=0.12, vol=1.0, when=0}){
        if(!ensure()) return;
        const t = ctx.currentTime + when;
        const osc = ctx.createOscillator();
        const g = env(t, dur);
        osc.type = type;
        if(f1!=null){
          osc.frequency.setValueAtTime(f0, t);
          osc.frequency.exponentialRampToValueAtTime(Math.max(1, f1), t + dur);
        }else{
          osc.frequency.setValueAtTime(f0, t);
        }
        const out = ctx.createGain();
        out.gain.value = vol;
        osc.connect(g).connect(out).connect(master);
        osc.start(t);
        osc.stop(t + dur + 0.2);
      }
      function noise({dur=0.12, vol=0.5, when=0, type="white"}){
        if(!ensure()) return;
        const t = ctx.currentTime + when;
        const bufferSize = Math.floor(ctx.sampleRate * dur);
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0;i<bufferSize;i++){
          let v = Math.random()*2-1;
          if(type==="brown"){ v = (data[i-1]||0)*0.98 + v*0.02; }
          data[i] = v;
        }
        const src = ctx.createBufferSource();
        src.buffer = buffer;
        const g = env(t, dur);
        const out = ctx.createGain(); out.gain.value = vol;
        src.connect(g).connect(out).connect(master);
        src.start(t);
      }
      const api = {
        initFromGesture(){ if(started) return; started = true; ensure(); api.startChime(); },
        setMuted(m){ muted = !!m; try{ localStorage.setItem(STORAGE_MUTE, muted ? "1":"0"); }catch(e){} },
        getMuted(){ if(muted) return true; try{ muted = localStorage.getItem(STORAGE_MUTE)==="1"; }catch(e){} return muted; },
        startChime(){ tone({type:"triangle", f0:440, f1:660, dur:0.12, vol:0.8}); tone({type:"triangle", f0:660, f1:880, dur:0.12, vol:0.7, when:0.08}); },
        jump(primary=true){ primary ? tone({type:"square", f0:520, f1:780, dur:0.09, vol:0.7}) : tone({type:"square", f0:780, f1:1100, dur:0.08, vol:0.75}); },
        pass(combo=0){ const base = 420 + Math.min(combo, 12)*22; tone({type:"sine", f0:base, f1:base*1.3, dur:0.06, vol:0.55}); },
        pickupLife(){ tone({type:"triangle", f0:620, f1:880, dur:0.1, vol:0.7}); tone({type:"triangle", f0:880, f1:1240, dur:0.1, vol:0.6, when:0.07}); },
        pickupInv(){ tone({type:"sawtooth", f0:360, f1:980, dur:0.18, vol:0.65}); },
        hit(){ noise({dur:0.08, vol:0.5, type:"brown"}); tone({type:"sine", f0:160, f1:80, dur:0.12, vol:0.6}); },
        gameOver(){ tone({type:"triangle", f0:440, f1:330, dur:0.18, vol:0.7}); tone({type:"triangle", f0:330, f1:220, dur:0.18, vol:0.6, when:0.12}); }
      };
      return api;
    })();

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = 0, H = 0, DPR = Math.max(1, Math.min(window.devicePixelRatio||1, 2));
    function resize(){
      W = canvas.clientWidth; H = canvas.clientHeight;
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // ---------- Game State ----------
    const EMOJIS = ["🐖","🦛","🐘","🐡","🐈","🦔","🦍","🐢","🦖","🐅"];
    const DEFAULT_EMOJI = EMOJIS[0];
    const STORAGE_KEY = "mc_runner_scores_v9";
    const MAX_RANK = 10;

    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const hud = document.getElementById('hud');
    const hudScore = document.getElementById('hudScore');
    const hudTime = document.getElementById('hudTime');
    const hudDiff = document.getElementById('hudDiff');
    const hudChar = document.getElementById('hudChar');
    const hudCombo = document.getElementById('hudCombo');
    const hudLives = document.getElementById('hudLives');
    const invTag = document.getElementById('invTag');
    const invLeftEl = document.getElementById('invLeft');
    const soundBtn = document.getElementById('btnSound');
    const soundIcon = document.getElementById('soundIcon');

    const rankListStart = document.getElementById('rankListStart');
    const rankListEnd = document.getElementById('rankListEnd');
    const finalScoreEl = document.getElementById('finalScore');
    const finalMetaEl = document.getElementById('finalMeta');

    let selectedEmoji = DEFAULT_EMOJI;
    let diff = "easy";
    let running = false;
    let score = 0;
    let elapsed = 0;

    // Ground & physics
    const groundH = 72;
    const gravity = 1800;
    const jumpV = 700;

    // Player with double jump + lives + invincibility
    const player = {
      x: 120, y: 0, w: 56, h: 56, vy: 0, onGround: false, emoji: DEFAULT_EMOJI, facingRight: true,
      jumpsLeft: 2,
      lives: 2, maxLives: 3,
      inv: 0, hitIFrames: 0,
      update(dt){
        this.vy += gravity * dt;
        this.y += this.vy * dt;
        const floor = H - groundH - this.h;
        if(this.y >= floor){
          this.y = floor; this.vy = 0;
          if(!this.onGround){ this.onGround = true; this.jumpsLeft = 2; }
        } else { this.onGround = false; }
        if(this.inv > 0){ this.inv -= dt; if(this.inv < 0) this.inv = 0; }
        if(this.hitIFrames > 0){ this.hitIFrames -= dt; if(this.hitIFrames < 0) this.hitIFrames = 0; }
      },
      jump(){
        if(this.jumpsLeft > 0){
          const isPrimary = (this.jumpsLeft === 2);
          this.vy = -jumpV;
          this.jumpsLeft--;
          SFX.jump(isPrimary);
          return true;
        }
        return false;
      },
      draw(){
        // Draw Twemoji image for cross-platform consistency
        const img = loadEmojiImage(this.emoji);
        const x = this.x, y = this.y;
        const sizeW = this.w, sizeH = this.h;
        ctx.save();
        if(this.facingRight){
          ctx.translate(x + sizeW/2, y);
          ctx.scale(-1, 1);
          if(img.complete) ctx.drawImage(img, -sizeW/2, 0, sizeW, sizeH);
        } else {
          if(img.complete) ctx.drawImage(img, x, y, sizeW, sizeH);
        }
        ctx.restore();

        // invincibility aura
        if(this.inv > 0 || this.hitIFrames > 0){
          ctx.save();
          ctx.globalAlpha = 0.5;
          ctx.strokeStyle = "rgba(255, 209, 102, 0.9)";
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.arc(x + sizeW/2, y + sizeH/2, 36, 0, Math.PI*2);
          ctx.stroke();
          ctx.restore();
        }
      }
    };

    // Obstacles
    const obstacles = [];
    function spawnObstacle(){
      const baseH = 24 + Math.random()*28;
      const width = 24 + Math.random()*24;
      const y = H - groundH - baseH;
      obstacles.push({x: W + 20, y, w: width, h: baseH, passed:false});
    }

    // Items (❤️ life, 🪨 invincibility)
    const items = [];
    const ITEM_EMOJI = { life: "❤️", inv: "🪨" };
    function spawnItem(type){
      const size = 40;
      const minY = H - groundH - 160;
      const maxY = H - groundH - 60;
      const y = Math.max(0, Math.min(maxY, minY + Math.random()*(maxY-minY)));
      items.push({type, x: W + 20, y, w: size, h: size});
    }
    function drawItems(){
      items.forEach(it=>{
        const img = loadEmojiImage(ITEM_EMOJI[it.type]);
        if(img.complete) ctx.drawImage(img, it.x, it.y, it.w, it.h);
      });
    }

    function resetGame(){
      obstacles.length = 0;
      items.length = 0;
      score = 0;
      elapsed = 0;
      combo = 0; comboTimer = 0;
      player.y = H - groundH - player.h;
      player.vy = 0; player.jumpsLeft = 2;
      player.lives = 2;
      player.inv = 0; player.hitIFrames = 0;
    }

    // Difficulty params (including item spawn intervals)
    const DIFF = {
      easy:   { speed: 360, spawnMin: 1.4, spawnMax: 1.9, passBonus: 50, lifeMin: 6,  lifeMax: 9,  invMin: 10, invMax: 14 },
      normal: { speed: 470, spawnMin: 1.0, spawnMax: 1.5, passBonus: 60, lifeMin: 9,  lifeMax: 13, invMin: 14, invMax: 18 },
      hard:   { speed: 600, spawnMin: 0.75, spawnMax: 1.2, passBonus: 70, lifeMin: 12, lifeMax: 18, invMin: 18, invMax: 24 }
    };
    let current = DIFF.easy;
    let spawnTimer = 0;
    let nextSpawnIn = 1.2;

    // Item spawn timers
    let lifeTimer = 0, nextLifeIn = 8;
    let invTimer = 0, nextInvIn = 12;

    function scheduleNextSpawn(){ nextSpawnIn = current.spawnMin + Math.random()*(current.spawnMax - current.spawnMin); spawnTimer = 0; }
    function scheduleLife(){ nextLifeIn = current.lifeMin + Math.random()*(current.lifeMax - current.lifeMin); lifeTimer = 0; }
    function scheduleInv(){ nextInvIn = current.invMin + Math.random()*(current.invMax - current.invMin); invTimer = 0; }

    // Combo system
    let combo = 0;
    let comboTimer = 0;
    const COMBO_WINDOW = 4.0;
    function onPassObstacle(){
      combo = Math.min(999, combo + 1);
      comboTimer = COMBO_WINDOW;
      const bonus = current.passBonus + combo * 10;
      score += bonus;
      SFX.pass(combo);
    }

    function startGame(){
      running = true;
      resize();
      resetGame();
      player.emoji = selectedEmoji;
      scheduleNextSpawn();
      scheduleLife();
      scheduleInv();
      hud.style.display = 'flex';
      hudDiff.textContent = `난이도: ${labelOf(diff)}`;
      hudChar.textContent = `캐릭터: ${player.emoji}`;
      startScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';
      prev = performance.now();
      SFX.startChime();
      loopId = requestAnimationFrame(loop);
    }
    function labelOf(d){ return d==="easy"?"하":(d==="normal"?"중":"상"); }

    function endGame(){
      running = false;
      hud.style.display = 'none';
      finalScoreEl.textContent = Math.floor(score);
      finalMetaEl.textContent = `난이도 ${labelOf(diff)} · 캐릭터 ${player.emoji} · 최고 콤보 x${combo}`;
      SFX.gameOver();
      showGameOver();
    }

    // Render helpers
    function drawGround(){
      ctx.fillStyle = "#f7fafc";
      ctx.fillRect(0, H-groundH, W, groundH);
      ctx.fillStyle = "#edf2f7";
      for(let i=0;i<6;i++){
        const y = H-groundH + i*12;
        ctx.fillRect(0, y, W, 1);
      }
    }

    // Main loop
    let prev = 0, loopId = 0;
    function loop(ts){
      if(!running) return;
      const dt = Math.min(0.033, (ts - prev)/1000 || 0);
      prev = ts;
      elapsed += dt;
      score += dt * 100; // time score

      // UPDATE
      player.update(dt);
      obstacles.forEach(ob=>{ ob.x -= current.speed * dt; });
      items.forEach(it=>{ it.x -= current.speed * dt * 0.95; });
      // cleanup
      for(let i=obstacles.length-1;i>=0;i--){
        const ob = obstacles[i];
        if(!ob.passed && (ob.x + ob.w) < player.x){ ob.passed = true; onPassObstacle(); }
        if(ob.x + ob.w < -20){ obstacles.splice(i,1); }
      }
      for(let i=items.length-1;i>=0;i--){
        if(items[i].x + items[i].w < -20){ items.splice(i,1); }
      }
      // spawns
      spawnTimer += dt; if(spawnTimer >= nextSpawnIn){ spawnObstacle(); scheduleNextSpawn(); }
      lifeTimer += dt; if(lifeTimer >= nextLifeIn){ spawnItem('life'); scheduleLife(); }
      invTimer += dt; if(invTimer >= nextInvIn){ spawnItem('inv'); scheduleInv(); }

      // combo decay
      if(combo > 0){
        comboTimer -= dt;
        if(comboTimer <= 0){ combo = 0; }
      }

      // collisions
      const px = player.x, py = player.y, pw = player.w, ph = player.h;
      if(player.inv<=0 && player.hitIFrames<=0){
        for(const ob of obstacles){
          if (px < ob.x + ob.w && px + pw > ob.x && py < ob.y + ob.h && py + ph > ob.y){
            if(player.lives > 0){
              player.lives -= 1;
              player.hitIFrames = 1.0;
              SFX.hit();
              break;
            }else{
              endGame(); break;
            }
          }
        }
      }
      for(let i=items.length-1;i>=0;i--){
        const it = items[i];
        if(px < it.x + it.w && px + pw > it.x && py < it.y + it.h && py + ph > it.y){
          if(it.type==='life'){
            if(player.lives < player.maxLives){ player.lives += 1; }
            SFX.pickupLife();
          } else if(it.type==='inv'){
            player.inv = 3.0; player.hitIFrames = 0;
            SFX.pickupInv();
          }
          items.splice(i,1);
        }
      }

      // draw
      ctx.clearRect(0,0,W,H);
      drawGround();
      obstacles.forEach(ob=>{
        const grad = ctx.createLinearGradient(ob.x, ob.y, ob.x, ob.y+ob.h);
        grad.addColorStop(0, "#ff7a17"); grad.addColorStop(1, "#c85e0f");
        ctx.fillStyle = grad; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
        ctx.fillStyle = "rgba(0,0,0,0.06)"; ctx.fillRect(ob.x, ob.y+ob.h, ob.w, 6);
      });
      drawItems();
      player.draw();

      // HUD
      hudScore.textContent = Math.floor(score);
      hudTime.textContent = `${elapsed.toFixed(1)}s`;
      hudCombo.textContent = combo;
      hudLives.innerHTML = '';
      for(let i=0;i<player.maxLives;i++){
        const span = document.createElement('span');
        span.textContent = i < player.lives ? '❤️' : '🤍';
        hudLives.appendChild(span);
      }
      if(player.inv > 0 || player.hitIFrames > 0){
        invTag.style.display = 'inline-flex';
        invLeftEl.textContent = (player.inv>0?player.inv:player.hitIFrames).toFixed(1);
      }else{
        invTag.style.display = 'none';
      }

      loopId = requestAnimationFrame(loop);
    }

    // Controls
    function onJump(e){ player.jump(); e && e.preventDefault(); }
    window.addEventListener('keydown', (e)=>{ if(e.code==="Space" || e.code==="ArrowUp"){ onJump(e); } });
    canvas.addEventListener('touchstart', (e)=>{ onJump(e); }, {passive:false});
    canvas.addEventListener('mousedown', (e)=>{ onJump(e); });

    // ---------- UI Wiring ----------
    const charGrid = document.getElementById('charGrid');
    let selectedIdx = 0;

    function renderCharGrid(){
      charGrid.innerHTML = "";
      EMOJIS.forEach((emj, idx)=>{
        const btn = document.createElement('button');
        btn.className = 'charBtn';
        btn.type = 'button';
        btn.dataset.selected = (idx===selectedIdx) ? "true" : "false";
        btn.setAttribute('aria-pressed', idx===selectedIdx ? 'true' : 'false');

        // Show Twemoji image in the picker too (for full cross-platform consistency)
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = emojiUrl(emj);
        img.alt = emj;
        btn.appendChild(img);

        btn.addEventListener('click', ()=>{
          selectedIdx = idx;
          selectedEmoji = EMOJIS[selectedIdx];
          Array.from(charGrid.children).forEach(el=>{ el.dataset.selected="false"; el.setAttribute('aria-pressed','false'); });
          btn.dataset.selected="true"; btn.setAttribute('aria-pressed','true');
        });
        charGrid.appendChild(btn);
      });
    }
    renderCharGrid();

    Array.from(document.querySelectorAll('input[name="difficulty"]')).forEach(r=>{
      r.addEventListener('change', ()=>{ diff = r.value; });
    });

    document.getElementById('btnStart').addEventListener('click', ()=>{
      current = DIFF[diff] || DIFF.easy;
      player.facingRight = true;
      SFX.initFromGesture(); // unlock audio
      startGame();
    });

    // Sound toggle
    function refreshSoundLabel(){
      const m = SFX.getMuted();
      soundIcon.textContent = m ? "🔇" : "🔊";
      soundBtn.textContent = m ? "사운드 OFF" : "사운드 ON";
    }
    refreshSoundLabel();
    document.querySelector('.soundToggle').addEventListener('click', ()=>{
      const willMute = !SFX.getMuted();
      SFX.setMuted(willMute);
      refreshSoundLabel();
    });

    // Ranking (Local Storage)
    function loadScores(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return [];
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr : [];
      }catch(e){ return []; }
    }
    function saveScores(arr){
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }
      catch(e){ /* ignore */ }
    }
    function addScore(entry){
      const arr = loadScores();
      arr.push(entry);
      arr.sort((a,b)=> b.score - a.score);
      if(arr.length > MAX_RANK) arr.length = MAX_RANK;
      saveScores(arr);
    }
    function rankTableHtml(containerId){
      const arr = loadScores();
      if(arr.length===0){
        document.getElementById(containerId).innerHTML = '<p class="muted">아직 기록이 없습니다.</p>';
        return;
      }
      const rows = arr.map((r, i)=>{
        const date = new Date(r.time||Date.now());
        const ds = date.toLocaleDateString();
        const ts = date.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        const meta = `${r.char||"?"} · ${labelOf(r.diff||"easy")} · x${r.combo||0}`;
        return `<tr>
          <td style="width:40px">${i+1}</td>
          <td style="width:80px;font-weight:700">${Math.floor(r.score)}</td>
          <td style="width:120px">${r.name ? escapeHtml(r.name) : '게스트'}</td>
          <td style="width:160px">${meta}</td>
          <td class="muted">${ds} ${ts}</td>
        </tr>`;
      }).join("");
      document.getElementById(containerId).innerHTML =
        `<table>
          <thead><tr><th>#</th><th>점수</th><th>이름</th><th>정보</th><th>기록시간</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>`;
    }
    function escapeHtml(str){ return (str+"").replace(/[&<>"']/g, s=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[s])); }

    document.getElementById('btnShowRank').addEventListener('click', ()=>{
      if(rankListStart.style.display==='none'){ rankTableHtml('rankListStart'); rankListStart.style.display='block'; }
      else { rankListStart.style.display='none'; }
    });
    document.getElementById('btnShowRank2').addEventListener('click', ()=>{
      if(rankListEnd.style.display==='none'){ rankTableHtml('rankListEnd'); rankListEnd.style.display='block'; }
      else { rankListEnd.style.display='none'; }
    });

    function showGameOver(){
      gameOverScreen.style.display = 'flex';
      rankListEnd.style.display = 'none';
      const nameEl = document.getElementById('playerName');
      document.getElementById('btnSaveScore').onclick = ()=>{
        const name = (nameEl.value || '게스트').trim().slice(0,20);
        addScore({ name, score: Math.floor(score), diff, char: player.emoji, combo, time: Date.now() });
        rankTableHtml('rankListEnd');
        rankListEnd.style.display = 'block';
        nameEl.value = '';
      };
      document.getElementById('btnRetry').onclick = ()=>{ current = DIFF[diff] || DIFF.easy; startGame(); };
      document.getElementById('btnGoHome').onclick = ()=>{
        cancelAnimationFrame(loopId);
        hud.style.display = 'none';
        startScreen.style.display = 'flex';
        gameOverScreen.style.display = 'none';
        renderCharGrid();
        rankListStart.style.display = 'none';
      };
    }
  })();
  </script>
</body>
</html>